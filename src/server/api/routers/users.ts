import { z } from "zod";
import {
  createTRPCRouter,
  globalAdminProcedure,
  protectedProcedure,
  publicProcedure,
} from "../trpc";
import argon2 from "argon2";
import {
  organisationMembers,
  organisations,
  sessions,
  users,
} from "@/server/db/schema";
import { TRPCError } from "@trpc/server";
import { and, eq, inArray } from "drizzle-orm";
import logger from "@/logging/logger";

const generatePassword = z
  .function()
  .args(z.number().optional().default(8))
  .returns(z.string())
  .implement((length) => {
    /*
    Passwords have a requirement of at least one upper case letter,
    at least one lower case letter, at least one number, and at least
    one special character. The autogenerated passwords have to follow
    this also, as the login form will reject any passwords that don't.
    */

    //Define the charsets so we can ensure we have at least one from each
    const lowercase = "abcdefghijklmnopqrstuvwxyz";
    const uppercase = lowercase.toUpperCase();
    const numbers = "0123456789";
    const specials = "!@#$%^&*()_+[]{}|;:,.<>?";
    const all = lowercase + uppercase + numbers + specials;

    //Grabs a random character out of the provided charset
    const getFromCharSet = (charSet: string) => {
      charSet[Math.floor(Math.random() * charSet.length)];
    };

    let password = "";
    //Ensure one of each type is incluided
    password += getFromCharSet(lowercase);
    password += getFromCharSet(uppercase);
    password += getFromCharSet(numbers);
    password += getFromCharSet(specials);

    //Fill the password to the specified length with random characters
    for (let i = password.length; i < length; i++) {
      password += getFromCharSet(all);
    }

    //Shuffle the password so the required chars aren't always in the same order
    return password
      .split("")
      .sort(() => 0.5 - Math.random())
      .join("");
  });

export const usersRouter = createTRPCRouter({
  create: globalAdminProcedure
    .input(
      z.object({
        email: z.string().email(),
        //Name and password are optional as they are only required for local accounts
        name: z.string().optional(),
        password: z
          .string()
          .min(8)
          //Contains an uppercase character
          .regex(/[A-Z]/)
          //Contains a lowercase character
          .regex(/[a-z]/)
          //contains a number
          .regex(/\d/)
          //contains a special character
          .regex(/\W/)
          .optional(),
        role: z.number().min(0).max(1),
        organisationId: z.string().uuid(),
        organisationRole: z.number().min(0).max(2),
        generatePassword: z.boolean().optional().default(false),
      }),
    )
    .output(z.object({ userId: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      logger.info(`Creating new user with email: ${input.email}`);
      const plaintext = input.generatePassword
        ? generatePassword(8)
        : input.password;

      const password = plaintext ? await argon2.hash(plaintext) : null;

      return await ctx.db.transaction(async (tx) => {
        try {
          const user = await tx
            .insert(users)
            .values({
              email: input.email,
              name: input.name,
              password: password,
              role: input.role,
            })
            .returning({ id: users.id });

          if (!user[0]) {
            logger.error("Failed to create user");
            tx.rollback();
            throw new TRPCError({ code: "INTERNAL_SERVER_ERROR" });
          }

          const orgMembership = await tx
            .insert(organisationMembers)
            .values({
              organisationId: input.organisationId,
              userId: user[0].id,
              role: input.organisationRole,
            })
            .returning();

          if (!orgMembership[0]) {
            logger.error("Failed to create organization membership");
            tx.rollback();
            throw new TRPCError({ code: "INTERNAL_SERVER_ERROR" });
          }

          logger.info(`User created successfully with ID: ${user[0].id}`);
          return { userId: user[0].id };
        } catch (e) {
          logger.error("Error creating user", { cause: e });
          tx.rollback();
          throw new TRPCError({ code: "INTERNAL_SERVER_ERROR" });
        }
      });
    }),

  delete: protectedProcedure
    .input(z.object({ userId: z.string() }).optional())
    .mutation(async ({ ctx, input }) => {
      if (input) {
        if (
          input.userId !== ctx.session.user.id &&
          ctx.session.user.role !== 1
        ) {
          logger.warn(
            `Unauthorized delete attempt for user ID: ${input.userId}`,
          );
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
      }

      const _id = input?.userId ?? ctx.session.user.id;
      logger.info(`Deleting user with ID: ${_id}`);

      return await ctx.db.transaction(async (tx) => {
        try {
          await tx
            .delete(organisationMembers)
            .where(eq(organisationMembers.userId, _id));

          const user = await tx
            .delete(users)
            .where(eq(users.id, _id))
            .returning({ id: users.id });

          logger.info(`User deleted successfully: ${user[0]?.id ?? ""}`);
          return { userId: user[0]?.id ?? "" };
        } catch (e) {
          logger.error(`Error deleting user with ID: ${_id}`, { cause: e });
          tx.rollback();
          throw new TRPCError({ code: "INTERNAL_SERVER_ERROR" });
        }
      });
    }),

  update: protectedProcedure
    .input(
      z.union([
        z.object({
          userId: z.string().uuid(),
          name: z.string().optional(),
          email: z.string().email().optional(),
          image: z.string().max(255).optional(),
          password: z.undefined(),
          role: z.number().min(0).max(1).optional(),
          requiresReset: z.boolean().optional(),
        }),
        z.object({
          userId: z.undefined(),
          name: z.string().optional(),
          email: z.string().email().optional(),
          image: z.string().max(255).optional(),
          password: z
            .string()
            .min(8)
            .regex(/[A-Z]/)
            .regex(/[a-z]/)
            .regex(/\d/)
            .regex(/\W/)
            .optional(),
          role: z.undefined(),
          requiresReset: z.boolean().optional(),
        }),
      ]),
    )
    .mutation(async ({ ctx, input }) => {
      const id = input.userId ?? ctx.session.user.id;
      logger.info(`Updating user with ID: ${id}`);

      if (input.userId) {
        if (ctx.session.user.role !== 1) {
          logger.warn(
            `Unauthorized update attempt for user ID: ${input.userId}`,
          );
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
      }

      try {
        const password = input.password
          ? await argon2.hash(input.password)
          : undefined;

        const updated = await ctx.db
          .update(users)
          .set({
            name: input.name,
            email: input.email,
            image: input.image,
            password: password,
            role: input.role,
            requiresReset: input.requiresReset,
          })
          .where(eq(users.id, id))
          .returning({ id: users.id });

        logger.info(`User updated successfully: ${updated[0]?.id}`);
        return updated[0];
      } catch (e) {
        logger.error(`Error updating user with ID: ${id}`, { cause: e });
        throw new TRPCError({ code: "INTERNAL_SERVER_ERROR" });
      }
    }),

  get: protectedProcedure
    .input(
      z
        .object({
          userId: z.string().uuid(),
          role: z.number().min(0).max(1).optional(),
        })
        .optional(),
    )
    .query(async ({ ctx, input }) => {
      if (!input) {
        if (ctx.session.user.role !== 1) {
          logger.warn("Unauthorized attempt to get all users");
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
        logger.info("Fetching all users");
        return await ctx.db
          .select({
            id: users.id,
            name: users.name,
            email: users.email,
            role: users.role,
            image: users.image,
          })
          .from(users)
          .all();
      }

      if (ctx.session.user.role !== 1 && ctx.session.user.id !== input.userId) {
        logger.warn(`Unauthorized get attempt for user ID: ${input.userId}`);
        throw new TRPCError({ code: "UNAUTHORIZED" });
      }

      logger.info(`Fetching user with ID: ${input.userId}`);
      return await ctx.db
        .select({
          id: users.id,
          name: users.name,
          email: users.email,
          role: users.role,
          image: users.image,
        })
        .from(users)
        .where(
          input.role
            ? and(eq(users.id, input.userId), eq(users.role, input.role))
            : eq(users.id, input.userId),
        );
    }),

  isWhitelisted: publicProcedure
    .input(z.object({ email: z.string().email() }))
    .output(z.boolean())
    .query(async ({ ctx, input }) => {
      logger.info(`Checking if email is whitelisted: ${input.email}`);
      const result =
        (
          await ctx.db
            .select({ id: users.id })
            .from(users)
            .where(eq(users.email, input.email))
        ).length !== 0;
      logger.info(`Email ${input.email} whitelisted: ${result}`);
      return result;
    }),

  getOrganisations: protectedProcedure
    .input(
      z
        .object({
          userId: z.string().uuid().optional(),
          role: z
            .number()
            .min(0)
            .max(2)
            .optional()
            .or(z.array(z.number().min(0).max(2))),
        })
        .optional(),
    )
    .query(async ({ ctx, input }) => {
      if (input?.userId) {
        if (
          ctx.session.user.role !== 1 &&
          ctx.session.user.id !== input.userId
        ) {
          logger.warn(
            `Unauthorized getOrganisations attempt for user ID: ${input.userId}`,
          );
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
      }

      const id = input?.userId ?? ctx.session.user.id;
      logger.info(`Fetching organizations for user ID: ${id}`);

      return await ctx.db
        .select({
          id: organisations.id,
          name: organisations.name,
          role: organisationMembers.role,
        })
        .from(organisationMembers)
        .leftJoin(
          organisations,
          eq(organisations.id, organisationMembers.organisationId),
        )
        .where(
          input?.role
            ? and(
                Array.isArray(input.role)
                  ? inArray(organisationMembers.role, input.role)
                  : eq(organisationMembers.role, input.role),
                eq(organisationMembers.userId, id),
              )
            : eq(organisationMembers.userId, id),
        );
    }),

  deleteSessions: protectedProcedure
    .input(z.object({ userId: z.string().uuid() }).optional())
    .mutation(async ({ ctx, input }) => {
      if (input) {
        if (
          ctx.session.user.role !== 1 &&
          input.userId !== ctx.session.user.id
        ) {
          logger.warn(
            `Unauthorized deleteSessions attempt for user ID: ${input.userId}`,
          );
          throw new TRPCError({ code: "UNAUTHORIZED" });
        }
      }
      const id = input?.userId ?? ctx.session.user.id;
      logger.info(`Deleting sessions for user ID: ${id}`);

      try {
        await ctx.db.delete(sessions).where(eq(sessions.userId, id));
        logger.info(`Sessions deleted successfully for user ID: ${id}`);
      } catch (e) {
        logger.error(`Error deleting sessions for user ID: ${id}`, {
          cause: e,
        });
        throw new TRPCError({ code: "INTERNAL_SERVER_ERROR" });
      }
    }),
});
